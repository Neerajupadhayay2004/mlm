{"ast":null,"code":"\"use client\";\n\n// src/toast.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport * as DismissableLayer from \"@radix-ui/react-dismissable-layer\";\nimport { Portal } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { VisuallyHidden } from \"@radix-ui/react-visually-hidden\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar PROVIDER_NAME = \"ToastProvider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(\"Toast\");\nvar [createToastContext, createToastScope] = createContextScope(\"Toast\", [createCollectionScope]);\nvar [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);\nvar ToastProvider = props => {\n  const {\n    __scopeToast,\n    label = \"Notification\",\n    duration = 5e3,\n    swipeDirection = \"right\",\n    swipeThreshold = 50,\n    children\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n  if (!label.trim()) {\n    console.error(`Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`);\n  }\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: __scopeToast,\n    children: /* @__PURE__ */jsx(ToastProviderProvider, {\n      scope: __scopeToast,\n      label,\n      duration,\n      swipeDirection,\n      swipeThreshold,\n      toastCount,\n      viewport,\n      onViewportChange: setViewport,\n      onToastAdd: React.useCallback(() => setToastCount(prevCount => prevCount + 1), []),\n      onToastRemove: React.useCallback(() => setToastCount(prevCount => prevCount - 1), []),\n      isFocusedToastEscapeKeyDownRef,\n      isClosePausedRef,\n      children\n    })\n  });\n};\nToastProvider.displayName = PROVIDER_NAME;\nvar VIEWPORT_NAME = \"ToastViewport\";\nvar VIEWPORT_DEFAULT_HOTKEY = [\"F8\"];\nvar VIEWPORT_PAUSE = \"toast.viewportPause\";\nvar VIEWPORT_RESUME = \"toast.viewportResume\";\nvar ToastViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    hotkey = VIEWPORT_DEFAULT_HOTKEY,\n    label = \"Notifications ({hotkey})\",\n    ...viewportProps\n  } = props;\n  const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n  const getItems = useCollection(__scopeToast);\n  const wrapperRef = React.useRef(null);\n  const headFocusProxyRef = React.useRef(null);\n  const tailFocusProxyRef = React.useRef(null);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n  const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n  const hasToasts = context.toastCount > 0;\n  React.useEffect(() => {\n    const handleKeyDown = event => {\n      const isHotkeyPressed = hotkey.length !== 0 && hotkey.every(key => event[key] || event.code === key);\n      if (isHotkeyPressed) ref.current?.focus();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [hotkey]);\n  React.useEffect(() => {\n    const wrapper = wrapperRef.current;\n    const viewport = ref.current;\n    if (hasToasts && wrapper && viewport) {\n      const handlePause = () => {\n        if (!context.isClosePausedRef.current) {\n          const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n          viewport.dispatchEvent(pauseEvent);\n          context.isClosePausedRef.current = true;\n        }\n      };\n      const handleResume = () => {\n        if (context.isClosePausedRef.current) {\n          const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n          viewport.dispatchEvent(resumeEvent);\n          context.isClosePausedRef.current = false;\n        }\n      };\n      const handleFocusOutResume = event => {\n        const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);\n        if (isFocusMovingOutside) handleResume();\n      };\n      const handlePointerLeaveResume = () => {\n        const isFocusInside = wrapper.contains(document.activeElement);\n        if (!isFocusInside) handleResume();\n      };\n      wrapper.addEventListener(\"focusin\", handlePause);\n      wrapper.addEventListener(\"focusout\", handleFocusOutResume);\n      wrapper.addEventListener(\"pointermove\", handlePause);\n      wrapper.addEventListener(\"pointerleave\", handlePointerLeaveResume);\n      window.addEventListener(\"blur\", handlePause);\n      window.addEventListener(\"focus\", handleResume);\n      return () => {\n        wrapper.removeEventListener(\"focusin\", handlePause);\n        wrapper.removeEventListener(\"focusout\", handleFocusOutResume);\n        wrapper.removeEventListener(\"pointermove\", handlePause);\n        wrapper.removeEventListener(\"pointerleave\", handlePointerLeaveResume);\n        window.removeEventListener(\"blur\", handlePause);\n        window.removeEventListener(\"focus\", handleResume);\n      };\n    }\n  }, [hasToasts, context.isClosePausedRef]);\n  const getSortedTabbableCandidates = React.useCallback(({\n    tabbingDirection\n  }) => {\n    const toastItems = getItems();\n    const tabbableCandidates = toastItems.map(toastItem => {\n      const toastNode = toastItem.ref.current;\n      const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n      return tabbingDirection === \"forwards\" ? toastTabbableCandidates : toastTabbableCandidates.reverse();\n    });\n    return (tabbingDirection === \"forwards\" ? tabbableCandidates.reverse() : tabbableCandidates).flat();\n  }, [getItems]);\n  React.useEffect(() => {\n    const viewport = ref.current;\n    if (viewport) {\n      const handleKeyDown = event => {\n        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n        const isTabKey = event.key === \"Tab\" && !isMetaKey;\n        if (isTabKey) {\n          const focusedElement = document.activeElement;\n          const isTabbingBackwards = event.shiftKey;\n          const targetIsViewport = event.target === viewport;\n          if (targetIsViewport && isTabbingBackwards) {\n            headFocusProxyRef.current?.focus();\n            return;\n          }\n          const tabbingDirection = isTabbingBackwards ? \"backwards\" : \"forwards\";\n          const sortedCandidates = getSortedTabbableCandidates({\n            tabbingDirection\n          });\n          const index = sortedCandidates.findIndex(candidate => candidate === focusedElement);\n          if (focusFirst(sortedCandidates.slice(index + 1))) {\n            event.preventDefault();\n          } else {\n            isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();\n          }\n        }\n      };\n      viewport.addEventListener(\"keydown\", handleKeyDown);\n      return () => viewport.removeEventListener(\"keydown\", handleKeyDown);\n    }\n  }, [getItems, getSortedTabbableCandidates]);\n  return /* @__PURE__ */jsxs(DismissableLayer.Branch, {\n    ref: wrapperRef,\n    role: \"region\",\n    \"aria-label\": label.replace(\"{hotkey}\", hotkeyLabel),\n    tabIndex: -1,\n    style: {\n      pointerEvents: hasToasts ? void 0 : \"none\"\n    },\n    children: [hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: headFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"forwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    }), /* @__PURE__ */jsx(Collection.Slot, {\n      scope: __scopeToast,\n      children: /* @__PURE__ */jsx(Primitive.ol, {\n        tabIndex: -1,\n        ...viewportProps,\n        ref: composedRefs\n      })\n    }), hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: tailFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"backwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    })]\n  });\n});\nToastViewport.displayName = VIEWPORT_NAME;\nvar FOCUS_PROXY_NAME = \"ToastFocusProxy\";\nvar FocusProxy = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    onFocusFromOutsideViewport,\n    ...proxyProps\n  } = props;\n  const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(VisuallyHidden, {\n    \"aria-hidden\": true,\n    tabIndex: 0,\n    ...proxyProps,\n    ref: forwardedRef,\n    style: {\n      position: \"fixed\"\n    },\n    onFocus: event => {\n      const prevFocusedElement = event.relatedTarget;\n      const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n      if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n    }\n  });\n});\nFocusProxy.displayName = FOCUS_PROXY_NAME;\nvar TOAST_NAME = \"Toast\";\nvar TOAST_SWIPE_START = \"toast.swipeStart\";\nvar TOAST_SWIPE_MOVE = \"toast.swipeMove\";\nvar TOAST_SWIPE_CANCEL = \"toast.swipeCancel\";\nvar TOAST_SWIPE_END = \"toast.swipeEnd\";\nvar Toast = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    ...toastProps\n  } = props;\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? true,\n    onChange: onOpenChange,\n    caller: TOAST_NAME\n  });\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */jsx(ToastImpl, {\n      open,\n      ...toastProps,\n      ref: forwardedRef,\n      onClose: () => setOpen(false),\n      onPause: useCallbackRef(props.onPause),\n      onResume: useCallbackRef(props.onResume),\n      onSwipeStart: composeEventHandlers(props.onSwipeStart, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"start\");\n      }),\n      onSwipeMove: composeEventHandlers(props.onSwipeMove, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"move\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-y\", `${y}px`);\n      }),\n      onSwipeCancel: composeEventHandlers(props.onSwipeCancel, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"cancel\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-y\");\n      }),\n      onSwipeEnd: composeEventHandlers(props.onSwipeEnd, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"end\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-y\", `${y}px`);\n        setOpen(false);\n      })\n    })\n  });\n});\nToast.displayName = TOAST_NAME;\nvar [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {}\n});\nvar ToastImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    type = \"foreground\",\n    duration: durationProp,\n    open,\n    onClose,\n    onEscapeKeyDown,\n    onPause,\n    onResume,\n    onSwipeStart,\n    onSwipeMove,\n    onSwipeCancel,\n    onSwipeEnd,\n    ...toastProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [node, setNode] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2));\n  const pointerStartRef = React.useRef(null);\n  const swipeDeltaRef = React.useRef(null);\n  const duration = durationProp || context.duration;\n  const closeTimerStartTimeRef = React.useRef(0);\n  const closeTimerRemainingTimeRef = React.useRef(duration);\n  const closeTimerRef = React.useRef(0);\n  const {\n    onToastAdd,\n    onToastRemove\n  } = context;\n  const handleClose = useCallbackRef(() => {\n    const isFocusInToast = node?.contains(document.activeElement);\n    if (isFocusInToast) context.viewport?.focus();\n    onClose();\n  });\n  const startTimer = React.useCallback(duration2 => {\n    if (!duration2 || duration2 === Infinity) return;\n    window.clearTimeout(closeTimerRef.current);\n    closeTimerStartTimeRef.current = (/* @__PURE__ */new Date()).getTime();\n    closeTimerRef.current = window.setTimeout(handleClose, duration2);\n  }, [handleClose]);\n  React.useEffect(() => {\n    const viewport = context.viewport;\n    if (viewport) {\n      const handleResume = () => {\n        startTimer(closeTimerRemainingTimeRef.current);\n        onResume?.();\n      };\n      const handlePause = () => {\n        const elapsedTime = (/* @__PURE__ */new Date()).getTime() - closeTimerStartTimeRef.current;\n        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n        window.clearTimeout(closeTimerRef.current);\n        onPause?.();\n      };\n      viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n      viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n      return () => {\n        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n      };\n    }\n  }, [context.viewport, duration, onPause, onResume, startTimer]);\n  React.useEffect(() => {\n    if (open && !context.isClosePausedRef.current) startTimer(duration);\n  }, [open, duration, context.isClosePausedRef, startTimer]);\n  React.useEffect(() => {\n    onToastAdd();\n    return () => onToastRemove();\n  }, [onToastAdd, onToastRemove]);\n  const announceTextContent = React.useMemo(() => {\n    return node ? getAnnounceTextContent(node) : null;\n  }, [node]);\n  if (!context.viewport) return null;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [announceTextContent && /* @__PURE__ */jsx(ToastAnnounce, {\n      __scopeToast,\n      role: \"status\",\n      \"aria-live\": type === \"foreground\" ? \"assertive\" : \"polite\",\n      \"aria-atomic\": true,\n      children: announceTextContent\n    }), /* @__PURE__ */jsx(ToastInteractiveProvider, {\n      scope: __scopeToast,\n      onClose: handleClose,\n      children: ReactDOM.createPortal(/* @__PURE__ */jsx(Collection.ItemSlot, {\n        scope: __scopeToast,\n        children: /* @__PURE__ */jsx(DismissableLayer.Root, {\n          asChild: true,\n          onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {\n            if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n            context.isFocusedToastEscapeKeyDownRef.current = false;\n          }),\n          children: /* @__PURE__ */jsx(Primitive.li, {\n            role: \"status\",\n            \"aria-live\": \"off\",\n            \"aria-atomic\": true,\n            tabIndex: 0,\n            \"data-state\": open ? \"open\" : \"closed\",\n            \"data-swipe-direction\": context.swipeDirection,\n            ...toastProps,\n            ref: composedRefs,\n            style: {\n              userSelect: \"none\",\n              touchAction: \"none\",\n              ...props.style\n            },\n            onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n              if (event.key !== \"Escape\") return;\n              onEscapeKeyDown?.(event.nativeEvent);\n              if (!event.nativeEvent.defaultPrevented) {\n                context.isFocusedToastEscapeKeyDownRef.current = true;\n                handleClose();\n              }\n            }),\n            onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n              if (event.button !== 0) return;\n              pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n              };\n            }),\n            onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n              if (!pointerStartRef.current) return;\n              const x = event.clientX - pointerStartRef.current.x;\n              const y = event.clientY - pointerStartRef.current.y;\n              const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n              const isHorizontalSwipe = [\"left\", \"right\"].includes(context.swipeDirection);\n              const clamp = [\"left\", \"up\"].includes(context.swipeDirection) ? Math.min : Math.max;\n              const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n              const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n              const moveStartBuffer = event.pointerType === \"touch\" ? 10 : 2;\n              const delta = {\n                x: clampedX,\n                y: clampedY\n              };\n              const eventDetail = {\n                originalEvent: event,\n                delta\n              };\n              if (hasSwipeMoveStarted) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                  discrete: false\n                });\n              } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                  discrete: false\n                });\n                event.target.setPointerCapture(event.pointerId);\n              } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                pointerStartRef.current = null;\n              }\n            }),\n            onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n              const delta = swipeDeltaRef.current;\n              const target = event.target;\n              if (target.hasPointerCapture(event.pointerId)) {\n                target.releasePointerCapture(event.pointerId);\n              }\n              swipeDeltaRef.current = null;\n              pointerStartRef.current = null;\n              if (delta) {\n                const toast = event.currentTarget;\n                const eventDetail = {\n                  originalEvent: event,\n                  delta\n                };\n                if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                    discrete: true\n                  });\n                } else {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {\n                    discrete: true\n                  });\n                }\n                toast.addEventListener(\"click\", event2 => event2.preventDefault(), {\n                  once: true\n                });\n              }\n            })\n          })\n        })\n      }), context.viewport)\n    })]\n  });\n});\nvar ToastAnnounce = props => {\n  const {\n    __scopeToast,\n    children,\n    ...announceProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n  useNextFrame(() => setRenderAnnounceText(true));\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);\n    return () => window.clearTimeout(timer);\n  }, []);\n  return isAnnounced ? null : /* @__PURE__ */jsx(Portal, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(VisuallyHidden, {\n      ...announceProps,\n      children: renderAnnounceText && /* @__PURE__ */jsxs(Fragment, {\n        children: [context.label, \" \", children]\n      })\n    })\n  });\n};\nvar TITLE_NAME = \"ToastTitle\";\nvar ToastTitle = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...titleProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...titleProps,\n    ref: forwardedRef\n  });\n});\nToastTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"ToastDescription\";\nvar ToastDescription = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...descriptionProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...descriptionProps,\n    ref: forwardedRef\n  });\n});\nToastDescription.displayName = DESCRIPTION_NAME;\nvar ACTION_NAME = \"ToastAction\";\nvar ToastAction = React.forwardRef((props, forwardedRef) => {\n  const {\n    altText,\n    ...actionProps\n  } = props;\n  if (!altText.trim()) {\n    console.error(`Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`);\n    return null;\n  }\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    altText,\n    asChild: true,\n    children: /* @__PURE__ */jsx(ToastClose, {\n      ...actionProps,\n      ref: forwardedRef\n    })\n  });\n});\nToastAction.displayName = ACTION_NAME;\nvar CLOSE_NAME = \"ToastClose\";\nvar ToastClose = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...closeProps\n  } = props;\n  const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(Primitive.button, {\n      type: \"button\",\n      ...closeProps,\n      ref: forwardedRef,\n      onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)\n    })\n  });\n});\nToastClose.displayName = CLOSE_NAME;\nvar ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    altText,\n    ...announceExcludeProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"data-radix-toast-announce-exclude\": \"\",\n    \"data-radix-toast-announce-alt\": altText || void 0,\n    ...announceExcludeProps,\n    ref: forwardedRef\n  });\n});\nfunction getAnnounceTextContent(container) {\n  const textContent = [];\n  const childNodes = Array.from(container.childNodes);\n  childNodes.forEach(node => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === \"none\";\n      const isExcluded = node.dataset.radixToastAnnounceExclude === \"\";\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n  return textContent;\n}\nfunction handleAndDispatchCustomEvent(name, handler, detail, {\n  discrete\n}) {\n  const currentTarget = detail.originalEvent.currentTarget;\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    cancelable: true,\n    detail\n  });\n  if (handler) currentTarget.addEventListener(name, handler, {\n    once: true\n  });\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\nvar isDeltaInDirection = (delta, direction, threshold = 0) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === \"left\" || direction === \"right\") {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\nfunction isHTMLElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some(candidate => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\nvar Provider = ToastProvider;\nvar Viewport = ToastViewport;\nvar Root2 = Toast;\nvar Title = ToastTitle;\nvar Description = ToastDescription;\nvar Action = ToastAction;\nvar Close = ToastClose;\nexport { Action, Close, Description, Provider, Root2 as Root, Title, Toast, ToastAction, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport, Viewport, createToastScope };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}